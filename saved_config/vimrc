set nocompatible
set noshowmode
filetype off

set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

Plugin 'VundleVim/Vundle.vim'
Plugin 'scrooloose/nerdtree'
Plugin 'scrooloose/syntastic'
Plugin 'altercation/vim-colors-solarized'
Plugin 'dmix/elvish.vim'
Bundle 'dag/vim-fish'
Plugin 'Shougo/deoplete.nvim'
Plugin 'roxma/vim-hug-neovim-rpc'
Plugin 'roxma/nvim-yarp'
Plugin 'ap/vim-buftabline'
Plugin 'tmhedberg/SimpylFold'

set encoding=utf-8

call vundle#end()

filetype plugin indent on
syntax on
set relativenumber
set number
set hls
set undodir=$HOME/.VIM_UNDO_FILES
set undofile
set undolevels=5000
set pastetoggle=<F2>
set magic
set viminfo='100,<500,s50
"Set tabs to 4 spaces
set tabstop=8 softtabstop=0 expandtab shiftwidth=4 smarttab
set foldmethod=indent
set foldnestmax=10
set foldlevelstart=99
set hidden

color solarized
set background=dark

"Statusline
hi User1 ctermfg=0 ctermbg=4
hi User2 ctermfg=4 ctermbg=0 cterm=underline

function! ChangeStatuslineColor()
    if (mode() =~# '\v(n|no)') "Normal mode
	exe 'hi User1 ctermfg=0 ctermbg=4'
	exe 'hi User2 ctermfg=4 ctermbg=0'
    elseif (mode() =~# '\v(v|V|)') "Visual mode
	exe 'hi User1 ctermfg=0 ctermbg=5'
	exe 'hi User2 ctermfg=5 ctermbg=0'
    elseif (mode() ==# 'i') "Insert mode
	exe 'hi User1 ctermfg=0 ctermbg=3'
	exe 'hi User2 ctermfg=3 ctermbg=0'
    else "Replace mode and other modes
	exe 'hi User1 ctermfg=0 ctermbg=1'
	exe 'hi User2 ctermfg=1 ctermbg=0'
    endif
    return ''
endfunction

set laststatus=2
"set statusline+=%#warningmsg#
"set statusline+=%{SyntasticStatuslineFlag()}
set statusline=""
"set statusline+=%1*%{(mode()=='n')?'[N]':(mode()=='i')?'[I]':(mode()=='R')?'[R]':'[V]'}
set statusline+=%{ChangeStatuslineColor()}
"set statusline+=%#DiffAdd#%{(mode()=='n')?'\ \ NORMAL\ ':''}
"set statusline+=%#DiffChange#%{(mode()=='i')?'\ \ INSERT\ ':''}
"set statusline+=%#DiffDelete#%{(mode()=='r')?'\ \ RPLACE\ ':''}
"set statusline+=%#Cursor#%{(mode()=='v')?'\ \ VISUAL\ ':''}
set statusline+=%{&paste?'\ PASTE\ ':''}
set statusline+=%{&spell?'\ SPELL\ ':''}
set statusline+=%1*%n:\ %f%m%2*\ %=%Y\ %1*\ Line:%l/%L\ [%p%%]

hi default link BufTabLineCurrent User1
hi default link BufTabLineActive User2
hi default link BufTabLineHidden User2
hi default link BufTabLineFill User2

"Makes you be able to move around on wrapping lines
noremap j gj
noremap k gk
map <F7> :w !xclip -selection c<CR><CR>
map <S-F7> :r!xclip -o<CR>
map <C-n> :NERDTreeToggle<CR>
map <F4> :NERDTreeToggle<CR>
cmap w!! w !sudo tee > /dev/null %
nnoremap <C-.> :bnext<CR>
nnoremap <C-,> :bprev<CR>
"Use space to toggle folds
noremap <space> za
noremap H :bprev<CR>
noremap L :bnext<CR>
noremap <C-w>1 :1b<CR>
noremap <C-w>2 :2b<CR>
noremap <C-w>3 :3b<CR>
noremap <C-w>4 :4b<CR>
noremap <C-w>5 :5b<CR>
noremap <C-w>6 :6b<CR>
noremap <C-w>7 :7b<CR>
noremap <C-w>8 :8b<CR>
noremap <C-w>9 :9b<CR>

let g:syntatic_always_populate_loc_list = 1
let g:syntatic_auto_loc_list = 1
let g:syntatic_check_on_open = 1
let g:syntatic_check_on_wq = 0
let g:deoplete#enable_at_startup = 1
let g:buftabline_numbers = 1

function! s:check_back_space() abort "{{{
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~ '\s'
endfunction"}}}

inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ deoplete#manual_complete()

"Set prolog syntax highlighting
au BufReadPost *.pro set syntax=prolog
command Diff execute 'w !git diff --no-index % -'
set tags=~/prog/.tags

if has("folding")
  set foldenable        " enable folding
  set foldmethod=syntax " fold based on syntax highlighting
  set foldlevelstart=99 " start editing with all folds open

  " toggle folds
  nnoremap <Space> za
  vnoremap <Space> za

  set foldtext=FoldText()
  function! FoldText()
    let l:lpadding = &fdc
    redir => l:signs
      execute 'silent sign place buffer='.bufnr('%')
    redir End
    let l:lpadding += l:signs =~ 'id=' ? 2 : 0

    if exists("+relativenumber")
      if (&number)
        let l:lpadding += max([&numberwidth, strlen(line('$'))]) + 1
      elseif (&relativenumber)
        let l:lpadding += max([&numberwidth, strlen(v:foldstart - line('w0')), strlen(line('w$') - v:foldstart), strlen(v:foldstart)]) + 1
      endif
    else
      if (&number)
        let l:lpadding += max([&numberwidth, strlen(line('$'))]) + 1
      endif
    endif

    " expand tabs
    let l:start = substitute(getline(v:foldstart), '\t', repeat(' ', &tabstop), 'g')
    let l:end = substitute(substitute(getline(v:foldend), '\t', repeat(' ', &tabstop), 'g'), '^\s*', '', 'g')

    let l:info = ' (' . (v:foldend - v:foldstart) . ')'
    let l:infolen = strlen(substitute(l:info, '.', 'x', 'g'))
    let l:width = winwidth(0) - l:lpadding - l:infolen

    let l:separator = ' … '
    let l:separatorlen = strlen(substitute(l:separator, '.', 'x', 'g'))
    let l:start = strpart(l:start , 0, l:width - strlen(substitute(l:end, '.', 'x', 'g')) - l:separatorlen)
    let l:text = l:start . ' … ' . l:end

    return l:text . repeat(' ', l:width - strlen(substitute(l:text, ".", "x", "g"))) . l:info
  endfunction
endif
