# DO NOT EDIT THIS FILE DIRECTLY
# This is a file generated from a literate programing source file located at
# https://github.com/zzamboni/elvish-themes/blob/master/chain.org.
# You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t

var prompt-segments-defaults = [ su arrow ]
var rprompt-segments-defaults = [ timestamp ]

use re
use str

#use github.com/muesli/elvish-libs/git

var prompt-segments = $prompt-segments-defaults
var rprompt-segments = $rprompt-segments-defaults

var default-glyph = [
    &su=            "⚡"
    &chain=         ""
    &session=       "▪"
    &arrow=         "$"
]

var default-segment-style = [
    &su=            [ yellow  ]
    &chain=         [ default ]
    &arrow=         [ white   ]
    &dir=           [ cyan    ]
    &session=       [ session ]
    &timestamp=     [ default ]
]

var glyph = [&]
var segment-style = [&]

var prompt-pwd-dir-length = 1

var timestamp-format = " %-I:%M:%S"

var root-id = 0

var bold-prompt = $false

fn -session-color {
    var valid-colors = [ black red green yellow blue magenta cyan lightgray gray lightred lightgreen lightyellow lightblue lightmagenta lightcyan white ]
    put $valid-colors[(% $pid (count $valid-colors))]
}

fn -colorized {|what @color|
    if (and (not-eq $color []) (eq (kind-of $color[0]) list)) {
        set color = [(all $color[0])]
    }
    if (and (not-eq $color [default]) (not-eq $color [])) {
        if (eq $color [session]) {
            set color = [(-session-color)]
        }
        if $bold-prompt {
            set color = [ $@color bold ]
        }
        styled $what $@color
    } else {
        put $what
    }
}

fn -glyph {|segment-name|
    if (has-key $glyph $segment-name) {
        put $glyph[$segment-name]
    } else {
        put $default-glyph[$segment-name]
    }
}

fn -segment-style {|segment-name|
    if (has-key $segment-style $segment-name) {
        put $segment-style[$segment-name]
    } else {
        put $default-segment-style[$segment-name]
    }
}

fn -colorized-glyph {|segment-name @extra-text|
    -colorized (-glyph $segment-name)(str:join "" $extra-text) (-segment-style $segment-name)
}

fn prompt-segment {|segment-or-style @texts|
    var style = $segment-or-style
    if (has-key $default-segment-style $segment-or-style) {
        set style = (-segment-style $segment-or-style)
    }
    if (has-key $default-glyph $segment-or-style) {
        set texts = [ (-glyph $segment-or-style) $@texts ]
    }
    var text = (str:join ' ' $texts)
    -colorized $text $style
}

var segment = [&]

var last-status = [&]

fn -any-staged {
    count [(each {|k|
        all $last-status[$k]
    } [staged-modified staged-deleted staged-added renamed copied])]
}

fn -prompt-pwd {
    var tmp = (tilde-abbr $pwd)
    if (== $prompt-pwd-dir-length 0) {
        put $tmp
    } else {
        re:replace '(\.?[^/]{'$prompt-pwd-dir-length'})[^/]*/' '$1/' $tmp
    }
}

fn -prompt-pwd2 {
    var abbr-length = 3
    var hidden-abbr = 4
    var @path = (re:split '/' (-prompt-pwd))
    var dir = $path[-1]
    put [(for parent $path[..-1] {
        if (str:has-prefix $parent '.') {
            if (> (count $parent) $hidden-abbr) {
                styled $parent[..$hidden-abbr] blue italic
            } else {
                styled $parent blue
            }
        } else {
            if (> (count $parent) $abbr-length) {
                styled $parent[..$abbr-length] blue italic
            } else {
                styled $parent blue
            }
        }
        styled '/' cyan
    }
    styled $path[-1] blue bold)]
}

set segment[dir] = {
    put (-colorized (-prompt-pwd) blue)
}

set segment[su] = {
    var uid = (id -u)
    if (eq $uid $root-id) {
        prompt-segment su
    }
}

set segment[timestamp] = {
    prompt-segment timestamp (date +$timestamp-format)
}

set segment[session] = {
    prompt-segment session
}

set segment[arrow] = {
    -colorized-glyph arrow " "
}

fn -interpret-segment {|seg|
    var k = (kind-of $seg)
    if (eq $k 'fn') {
        # If it's a lambda, run it
        $seg
    } elif (eq $k 'string') {
        if (has-key $segment $seg) {
            # If it's the name of a built-in segment, run its function
            $segment[$seg]
        } else {
            # If it's any other string, return it as-is
            put $seg
        }
    } elif (or (eq $k 'ui:text') (eq $k 'styled') (eq $k 'styled-text')) {
        # If it's a styled object, return it as-is
        put $seg
    }
}

fn -build-chain {|segments|
    if (eq $segments []) {
        return
    }
    var first = $true
    var output = ""
    #-parse-git
    for seg $segments {
        set output = [(-interpret-segment $seg)]
        if (> (count $output) 0) {
            if (not $first) {
                -colorized-glyph chain
            }
            put $@output
            set first = $false
        }
    }
}


fn prompt {
  -build-chain [(all (-prompt-pwd2)) $@prompt-segments]
  # if (not-eq $prompt-segments []) {
  #   -build-chain $prompt-segments
  # }
}

fn rprompt {
    if (not-eq $rprompt-segments []) {
        -build-chain $rprompt-segments
    }
}

fn init {
    set edit:prompt = $prompt~
    set edit:rprompt = $rprompt~
}

init
